# Sloppy encryptor Write-Up

| Δοκιμασία | Sloppy encryptor |
| :------- | :----- |
| Δυσκολία | Μέτρια |
| Κατηγορία | Κρυπτογραφία (Cryptography) / Προγραμματισμός (Programming) |
| Λύσεις | 20 |
| Πόντοι | 149 |

## Περιγραφή Δοκιμασίας
```
Εάν το αντίθετο της κρυπτογράφησης είναι η αποκρυπτογράφηση και το αντίθετο της απρόσεκτης είναι προσεκτική, τότε το αντίθετο αυτής της απρόσεκτης κρυπτογράφησης θα πρέπει να είναι προσεκτική αποκρυπτογράφηση.
```
## Επίλυση 

Μας δίνεται ένα κρυπτογραφημένο αρχείο που περιέχει ένα μη ευανάγνωστο κείμενο και το αρχείο που χρησιμοποιήθηκε για την παραγωγή του.

```
Το κρυπτογραφημένο κείμενο είναι: jkfdhlhfggkdekgkjfgkkgehhjjeflefgekiifehmmifdjigeldedleghhlejgeefehdeeffdkefefhkmiffkiefemeedemkmmehiidegjefefgfeefejfiifdmhlfdlidfifefieii
```

```py
'''
Το αρχείο που το δημιούργησε είναι:
'''

from random import randint as rint
from secret_stuff import FLAG

def encrypt(FLAG):
    return "".join([str(ord(c))+str(rint(126, 254)) for c in FLAG])

def toBytes(enc):
    return "".join([chr(int(enc[i])+100) for i in range(len(enc))])

with open("./flag.enc","w") as f:
    enc = encrypt(FLAG)
    enc_ = toBytes(enc)
    f.write(enc_)

```

### Διαδικασία κρυπτογράφησης του κειμένου

Μπορούμε να διακρίνουμε ότι ο πηγαίος κώδικας που κρυπτογράφησε το κείμενο ακολουθεί τα εξής επιμέρους βήματα: 

1. Παίρνει κάθε χαρακτήρα του plaintext και τον μετατρέπει στον αντίστοιχο `Ascii` αριθμό.

2. Μετατρέπει αυτόν τον `Ascii` αριθμό τύπου integer σε τύπου string.

3. Του προσθέτει έναν τυχαίο αριθμό στο εύρος `[126, 254]`. Δηλαδή έστω `p` ο αρχικός αριθμός του plaintext και `r` ο τυχαίος αριθμός που ∊ [126, 254]. Τότε c = 'p' + 'r' = 'pr' ο αντίστοιχος κρυπτογραφημένος χαρακτήρας.

Ο παραπάνω τρόπος κρυπτογράφησης δεν κάνει τίποτα περισσότερο από το να βάλει ενδιάμεσα από κάθε χαρακτήρα του αρχικού κειμένου τυχαίους αριθμούς.

Ύστερα, το πλέον τροποποιημένο κείμενο υπόκειται σε επιπλέον τροποποίηση με την συνάρτηση toBytes(), όπου η συνάρτηση αυτή κάνει το εξής:

1. Παίρνει τον κάθε αριθμό του τροποποιημένου κειμένου και του προσθέτει τον αριθμό 100. Δηλαδή έστω `i` ο αντίστοιχος αριθμός του `i`-στου γράμματος του τροποποιημένου κειμένου. Τότε i' = i + 100.

2. Παίρνει την αντίστοιχη `Ascii` αναπαράσταση του αριθμού αυτού σε χαρακτήρα.

3. Ενώνει το αποτέλεσμα χαρακτήρων σε ένα ενιαίο string και το επιστρέφει.

### Διαδικασία αποκρυπτογράφησης του κρυπτογραφημένου κειμένου

Ένα πρώτο βήμα για την αποκρυπτογράφηση του κρυπτογραφημένου κειμένου είναι να αφαιρέσουμε από κάθε χαρακτήρα τον αριθμό 100. Αυτό είναι επιθυμητό καθώς στην διαδικασία κρυπτογράφησης είχε προστεθεί ο αριθμός 100 σε κάθε χαρακτήρα.

```py
'''
Ανοίγουμε το κρυπτοκείμενο και αφαιρούμε από κάθε δεκαδική αναπαράσταση του κάθε χαρακτήρα τον αριθμό 100.
'''

with open("../flag.enc","r") as f:
    enc = f.read()

flag_enc = "".join([str(ord(i)-100) for i in enc])
print(flag_enc)
```

Το αποτέλεσμα της παραπάνω διαδικασίας είναι το ακόλουθο:
```
> python decryptor.py
702187616365133711791231715224295148531981082374821411215311217812125395148511801101269924050170121140112149552194815950192125143
```

Εφόσον ξέρουμε ότι το flag format είναι `FLAG{}` και ξέρουμε ότι ο αλγόριθμος κρυπτογράφησης πρόσθετε τυχαίους αριθμούς ανάμεσα σε κάθε χαρακτήρα στο εύρος [126,254], μπορούμε εύκολα να διακρίνουμε μερικά γράμματα. Ας δούμε τα πρώτα 10 ψηφιά του προηγούμενου αποτελέσματος:
```
7021876163
--> 70 ήταν ο πρώτος χαρακτήρας.

Μετά προστέθηκε ανάμεσα σε αυτόν και τον 2ο χαρακτήρα ένας τριψήφιος τυχαίος αριθμός

--> 218 είναι ο τυχαίος αριθμός που προστέθηκε ανάμεσά τους.
Μετά ακολουθεί ο επόμενος χαρακτήρας του αρχικού κειμένου.

--> 76
Μετά ακολουθεί ο επόμενος τυχαίος αριθμός.

--> 163
...

Αν πάρουμε την αναπαράσταση των αριθμών που βρήκαμε ότι αναλογούν στους 2 πρώτους χαρακτήρες του αρχικού κειμένου, θα δούμε ότι:
1) chr(70) --> 'F'
2) chr(76) --> 'L'
Μας θυμίζει το flag format ('FLAG').
```

Στην ουσία αντί να κάνει 70 + 128 που θα έκανε 198 κάνει '70' + '128'

Δηλαδή κάνει append strings μεταξύ τους. 
```py
test = "this is" + "a test"
print(test) # this is a test
```
Η διαδικασία είναι πολύ απλή για την ανάκτηση του αρχικού κειμένου και μπορούμε να το αυτοματοποιήσουμε.

Ένας τρόπος να το κάνουμε αυτό είναι το παρακάτω πρόγραμμα, αλλά ο καθένας μπορεί να δημιουργήσει το δικό του:

```py
def getNum(start, end, flag):
    flag = "".join(flag)
    return flag[start:end]

with open("../flag.enc","r") as f:
    enc = f.read()

flag_enc = "".join([str(ord(i) - 100) for i in enc])

flag_dec = []
start = 0
end = 3
flag_enc = list(flag_enc)
while flag_enc:
    enc = getNum(start, end, flag_enc)

    if int(enc) > 0xff:
        end = 2
        continue

    if int(enc) < 126:
        flag_dec.append(int(enc))
        flag_enc = list(flag_enc)
        del flag_enc[start: end]
        end = 3
    else:
        del flag_enc[start: end]
    
print("".join([chr(i) for i in flag_dec]))
```

Εκτελώντας το παραπάνω πρόγραμμα, παίρνουμε την σημαία:
```
> python decryptor.py
FLAG{4_5l0ppy_3nc2yp702}
```
